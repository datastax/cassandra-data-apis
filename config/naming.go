package config

import (
	"fmt"
	"github.com/iancoleman/strcase"
	"sort"
	"strings"
)

type NamingConvention interface {
	// ToCQLColumn converts a GraphQL/REST name to a CQL column name.
	ToCQLColumn(tableName string, fieldName string) string

	// ToCQLColumn converts a GraphQL/REST name to a CQL table name.
	ToCQLTable(name string) string

	// ToGraphQLField converts a CQL name (typically a column name) to a GraphQL field name.
	ToGraphQLField(tableName string, columnName string) string

	// ToGraphQLOperation converts a CQL name (typically a table name) to a GraphQL operation name.
	ToGraphQLOperation(prefix string, name string) string

	// ToGraphQLType converts a CQL name (typically a table name) to a GraphQL type name.
	ToGraphQLType(name string) string

	// ToGraphQLType converts a CQL table name to a GraphQL while also checking that the type name doesn't collide
	// with types generated by a table name.
	// For example: calls for ToGraphQLTypeUnique("tbl_one", "input") will return
	// - "TblOneInput" when there isn't a table that generates the same name
	// - "TblOneInput2" when there is a table that generates the same name
	ToGraphQLTypeUnique(name string, suffix string) string
}

type NamingConventionFn func(KeyspaceNamingInfo) NamingConvention

type KeyspaceNamingInfo interface {
	// A map containing the table names as keys and the column names as values
	Tables() map[string][]string
}

const reservedNameSuffix = "Custom"

func NewDefaultNaming(info KeyspaceNamingInfo) NamingConvention {
	dbTables := info.Tables()
	tableNames := make([]string, 0, len(dbTables))
	for k := range dbTables {
		tableNames = append(tableNames, k)
	}
	// Use a sorted slice of table names to have deterministic behaviour (map keys order is not guaranteed)
	sort.Strings(tableNames)

	entitiesByTables := make(map[string]string, len(dbTables))
	tablesByEntities := make(map[string]string, len(dbTables))
	fieldsByColumns := make(map[string]map[string]string, len(dbTables))
	columnsByFields := make(map[string]map[string]string, len(dbTables))

	for _, tableName := range tableNames {
		columns := dbTables[tableName]
		fieldByColumnName := make(map[string]string, len(columns))
		columnNameByField := make(map[string]string, len(columns))

		for _, columnName := range columns {
			fieldName := generateAvailableName(strcase.ToLowerCamel(columnName), columnNameByField)
			fieldByColumnName[columnName] = fieldName
			columnNameByField[fieldName] = columnName
		}

		entityName := strcase.ToCamel(tableName)
		if isReserved(entityName) {
			entityName += reservedNameSuffix
		}
		entityName = generateAvailableName(entityName, tablesByEntities)

		entitiesByTables[tableName] = entityName
		fieldsByColumns[tableName] = fieldByColumnName
		columnsByFields[tableName] = columnNameByField
		tablesByEntities[entityName] = tableName
	}

	result := snakeCaseToCamelNaming{
		entitiesByTables: entitiesByTables,
		tablesByEntities: tablesByEntities,
		fieldsByColumns:  fieldsByColumns,
		columnsByFields:  columnsByFields,
	}
	return &result
}

func generateAvailableName(baseName string, nameMap map[string]string) string {
	if _, found := nameMap[baseName]; !found {
		return baseName
	}
	for i := 2; i < 1000; i++ {
		name := fmt.Sprintf("%s%d", baseName, i)
		_, found := nameMap[name]
		if !found {
			return name
		}
	}

	panic("Name was repeated more than 1000 times")
}

func isReserved(name string) bool {
	switch name {
	case "BasicType", "Bigint", "Blob", "Column", "ColumnInput", "ColumnKind", "Consistency", "ClusteringKeyInput",
		"DataType", "DataTypeInput", "Decimal", "QueryOptions", "Table", "Query", "Mutation", "Time",
		"Timestamp", "TimeUuid", "UpdateOptions", "Uuid", "Varint":
		return true
	}

	if strings.HasSuffix(name, "FilterInput") {
		// We create one input type per scalar, like IntFilterInput
		// It's best to mark anything that "FilterInput" as reserved
		return true
	}

	return false
}

type snakeCaseToCamelNaming struct {
	entitiesByTables map[string]string
	tablesByEntities map[string]string
	columnsByFields  map[string]map[string]string
	fieldsByColumns  map[string]map[string]string
}

func (n *snakeCaseToCamelNaming) ToCQLColumn(tableName string, fieldName string) string {
	// lookup column by fields
	columnName, found := n.columnsByFields[tableName][fieldName]
	if !found {
		return strcase.ToSnake(fieldName)
	}
	return columnName
}

func (n *snakeCaseToCamelNaming) ToCQLTable(name string) string {
	// lookup table name by entity name
	tableName, found := n.tablesByEntities[name]
	if !found {
		// Default to snake_case for tables that doesn't exist yet (DDL)
		return strcase.ToSnake(name)
	}
	return tableName
}

func (n *snakeCaseToCamelNaming) ToGraphQLField(tableName string, columnName string) string {
	// lookup fields by columns
	fieldName, found := n.fieldsByColumns[tableName][columnName]
	if !found {
		return strcase.ToLowerCamel(columnName)
	}
	return fieldName
}

func (n *snakeCaseToCamelNaming) ToGraphQLOperation(prefix string, tableName string) string {
	entityName := n.ToGraphQLType(tableName)
	if prefix == "" {
		return strcase.ToLowerCamel(entityName)
	} else {
		return strcase.ToLowerCamel(prefix) + entityName
	}
}

func (n *snakeCaseToCamelNaming) ToGraphQLType(name string) string {
	entityName, found := n.entitiesByTables[name]
	if !found {
		// Default to Camel for entities that doesn't exist yet (DDL)
		return strcase.ToCamel(name)
	}
	return entityName
}

func (n *snakeCaseToCamelNaming) ToGraphQLTypeUnique(name string, suffix string) string {
	entityName := n.ToGraphQLType(name)
	return generateAvailableName(entityName+strcase.ToCamel(suffix), n.tablesByEntities)
}
